#  CVE-2018-18500 : write-after-free vulnerability in Firefox, Analysis and Exploitation
  
  
해당 취약점은 `SoposLab`에 의해 발견되었다.<br>
  
이 취약점은 `Gecko[Firefox browser engine]`의 웹 페이지 parsing코드에서 발생한다.<br>
  
해당 버그의 `root cause`는 C++객체가 올바르게 참조되지 않고 free된 객체가 사용되어 `Write After Free`취약점을 발생시킨다.<br>
  
##  Backgroud - Custom Elements
  
  
![element](https://github.com/Kieast/image/blob/master/element.png?raw=true )
  
<br>
  
  
`Custom Elements`는 HTML요소를 작성하는 방법을 제공한다.<br>
  
위의 예는 `customized built-in element`를 `is`를 사용하여 변형시킨다.<br>
  
##  BUG
  
  
이 버그는 Firefox가 HTML트리 구성 프로세스에서 사용자 정의 요소를 작성할 때 발생한다.<br>
  
이 프로세스에서 엔진 코드는 일치하는 ` custom element definition’s constructor function`을 호출하기 위해 Javascript Callback을 전달한다.<br>
  
이때 엔진 코드는 C++ 객체를 참조하지 않고, C++객체를 사용한다.<br>
  
JavaScript Callback함수에서 리턴한 뒤에, 엔진 코드가 실행하면, C++ 객체의 멤버 변수에Write를 한다.<br>
  
그러나, 호출된 `construction funciton`은 `documnet load의 abortion`을 발생시킨다.<br>
  
이 경우 `Wrie-After-Free` 메모리 버그가 발생한다.<br>
  
`HTML Element`를 만들기 위한 HTML5 파서 코드의 관련부분은 아래와 같다.<br>
  
  
```c
nsresult
nsHtml5TreeOperation::[1]Perform(nsHtml5TreeOpExecutor* aBuilder,
                              nsIContent** aScriptElement,
                              bool* aInterrupted,
                              bool* aStreamEnded)
{
  switch (mOpCode) {
    ...
    case eTreeOpCreateHTMLElementNetwork:
    case eTreeOpCreateHTMLElementNotNetwork: {
      nsIContent** [2]target = mOne.node;
      ...
      *target = [3]CreateHTMLElement(name,   // line 13
                                  attributes,
                                  mOpCode == eTreeOpCreateHTMLElementNetwork
                                    ? dom::FROM_PARSER_NETWORK
                                    : dom::FROM_PARSER_DOCUMENT_WRITE,
                                  nodeInfoManager,
                                  aBuilder,
                                  creator);
      return NS_OK;
    }
    ...
}
  
nsIContent*
nsHtml5TreeOperation::CreateHTMLElement(
  nsAtom* aName,
  nsHtml5HtmlAttributes* aAttributes,
  mozilla::dom::FromParser aFromParser,
  nsNodeInfoManager* aNodeInfoManager,
  nsHtml5DocumentBuilder* aBuilder,
  mozilla::dom::HTMLContentCreatorFunction aCreator)
{
  ...
  if (nsContentUtils::IsCustomElementsEnabled()) {
    ...
    if (isCustomElement &amp;&amp; aFromParser != dom::FROM_PARSER_FRAGMENT) {
      ...
      definition = nsContentUtils::LookupCustomElementDefinition(
        document, nodeInfo-&gt;NameAtom(), nodeInfo-&gt;NamespaceID(), typeAtom);
  
      if (definition) {
        willExecuteScript = true;
      }
    }
  }
  
  if (willExecuteScript) { // This will cause custom element
                           // constructors to run
    ...
    nsCOMPtr<dom::Element&gt; newElement;
    [4]NS_NewHTMLElement(getter_AddRefs(newElement),
                      nodeInfo.forget(),
                      aFromParser,
                      isAtom,
                      definition);
    ...
```    
<br>
  
 `[4]NS_NewHTMLElement`에서 작성중인 요소가 사용자 정의요소인 `CustomElementRegistry::Upgrade`인 경우, `custom element’s constructor`를 호출해, Javascript로 제어권을 넘기게 된다.<br>
  
`custom element constructor`가 동작은 마친후에, `[3]CreateHTMLElement()`는 `[2]Perform()`을 실행시킨다.<br>
  
line 13에서 그 실행이 종료된다.<br>
  
이때, `CreateHTMLElement()`의 값이 `[1]target`에 의해 지정된 메모리 주소에 써지게 된다.<br>
  
따라서, `target point`가 무엇인지, 어디가 설정되어있는지, 어떻게 free를 시키는지, 어떤 값이 써지는지 알아보자.<br>
  
##  What's "target"?
  
  
위의 코드에서 보면 `taget`은 line 11에서 볼수있다. : `nsIContent** [2]target = mOne.node;`<br>
  
```c
nsIContentHandle*
nsHtml5TreeBuilder::createElement(int32_t aNamespace,
                                  nsAtom* aName,
                                  nsHtml5HtmlAttributes* aAttributes,
                                  nsIContentHandle* aIntendedParent,
                                  nsHtml5ContentCreatorFunction aCreator)
{
  ...
    nsIContent* elem;
    if (aNamespace == kNameSpaceID_XHTML) {
      elem = nsHtml5TreeOperation::CreateHTMLElement(
        name,
        aAttributes,
        mozilla::dom::FROM_PARSER_FRAGMENT,
        nodeInfoManager,
        mBuilder,
        aCreator.html);
    }
  ...
  nsIContentHandle* content = [1]AllocateContentHandle();
  ...
  treeOp-&gt;Init(aNamespace,
               aName,
               aAttributes,
               content,
               aIntendedParent,
               !!mSpeculativeLoadStage,
               aCreator);
  
inline void Init(int32_t aNamespace,
                 nsAtom* aName,
                 nsHtml5HtmlAttributes* aAttributes,
                 nsIContentHandle* aTarget,
                 nsIContentHandle* aIntendedParent,
                 bool aFromNetwork,
                 nsHtml5ContentCreatorFunction aCreator)
    {
        ...
        mOne.node = static_cast<nsIContent**&gt;(aTarget);
        ...
    }
```
  
따라서 `taget`의 값은 `[1]AllocateContentHandle()`에서 온다.<br>
  
```c
nsIContentHandle*
nsHtml5TreeBuilder::AllocateContentHandle()
{
  ...
  return &amp;mHandles[mHandlesUsed++];
}
```
 `mHandles`는 `nsHtml5TreeBuilder`의 초기화 리스트 생성자에 의해 초기화된다.<br>
  
 ```c
 nsHtml5TreeBuilder::nsHtml5TreeBuilder(nsAHtml5TreeOpSink* aOpSink,
                                       nsHtml5TreeOpStage* aStage)
  ...
  , mHandles(new nsIContent*[NS_HTML5_TREE_BUILDER_HANDLE_ARRAY_LENGTH])
  ...
  ```
따라서, `NS_HTML5_TREE_BUILDER_HANDLE_ARRAY_LENGTH`(512)에 대한 포인터를 가진 `nsIContent`배열이 먼저 초기화되며, `AllocateContentHandle()`이 호출 될때마다 인덱스 0번부터 시작하여 배열에서 사용되지 않은 다음 슬롯을 반환한다.<br>
  
64-bit 시스템에서, `mHandles`의 할당 사이즈는 4096이다.<br>
```c
NS_HTML5_TREE_BUILDER_HANDLE_ARRAY_LENGTH * sizeof(nsIContent*) == 512 * 8 == 4096 (0x1000)
```
  
##  How to get mHandles freed?
  
  
`mHandles`는 class `nsHtml5TreeBuilder`의 멤버이다.<br>
  
`nsHtml5TreeBuilder`는 `nsHtml5StreamParser`에 의해 초기화되, `nsHtml5Parser`로 인스턴스화 된다.<br>
  
```c
location.replace("about:blank");
```
위의 자바스크립트 코드를 사용할것이다.<br>
  
브라우저에게 현재 페이지를 벗어나 엔진에서 아래 call tree를 실행시키도록 한다.<br>
  
```c
Location::SetURI()
-> nsDocShell::LoadURI()
   -> nsDocShell::InternalLoad()
      -> nsDocShell::Stop()
         -> nsDocumentViewer::Stop()
            -> nsHTMLDocument::StopDocumentLoad()
               -> nsHtml5Parser::Terminate()
                  -> nsHtml5StreamParser::Release()
```
  
마지막 함수 호출은  `nsHtml5StreamParser` 객체에 대한 참조를 삭제하지만 아직 활성화 상태이다.<br>
  
나머지 참조는  Gecko의 다음 `event loop`가 돌때, 예약되는 몇 가지 비동기 작업에 의해 삭제된다.<br>
  
JavaScript의 특성중 하나로 `Never Blocking`이라는 것이 있는데, JavaScript 함수를 실행하는 광정에 일반적으로 발생하지 않지만, 버그를 트리거하기위해서는 `custom element constructor`가 리턴되기 전에 비동기작업을 실행해야 한다.<br>
  
여기서, XHR을 이용하는데 웹 서버에서 데이터를 검색하는 데 사용할 수있는 API이다.<br>
  
 ` synchronous XHR`를 사용하여, 브라우저 엔진의 eventloop가 XHR call이 완료될 때까지, 돌도록 하는 것이다.<br>
  
 ```c
 location.replace("about:blank");
  
var xhr = new XMLHttpRequest();
xhr.open('GET', '/delay.txt', false);
xhr.send(null);
 ```
  
다음과 코드를 사용하는데, `/delay.txt`를 통해 인위적으로 웹서버가 `eventloop`를 돌면서 오랜 지연을 일으키기도록 한뒤에, line 5가 실행 완료함으로써 현재 환성화된 `nsHtml5StreamParser`가 `orphan`상태가 된다.<br>
  
따라서 다음에 가비지 컬렉션 주기 발생하면 `nsHtml5StreamParser`객체가 삭제되고 자원이 할당 해제된다.<br>
  
`about:blank`는 빈페이지이므로 새 위치에 사용된다.<br>
  
목표는 `nsHtml5StreamParser`객체 삭제와 `Write-After-Free`사이에서 엔진이 최소한의 동작을 하도록 하는것이다.<br>
  
##  What value is being written to freed memory?
  
  
`nsHtml5TreeOperation::CreateHTMLElement`의 return값은 `HTMLTableElement`나 `HTMLFormElement`에 의해 새로 생긴 C++객체의 포인터 이다.<br>
  
버그를 트리거하기 위해서는 현재 동작중인 `document parser`를 중단시켜야하므로, 이 새로운 객체는 기존의 데이터에 연결되지 않고, `orphan`상태로 남아있게되고, 최종적으로 garbage collection에 의해 참조가 해제된다.<br>
  
##  Controlling write-after-free offset
  
  
```c
nsIContent* mHandles[] = moz_xmalloc(0x1000);
nsIContent** target = &amp;mHandles[mHandlesUsed++];
free(mHandles);
...
*target = CreateHTMLElement(...);
```
위와 같은 코드를 사용하여 버그를 트리거할수있다.<br>
  
여기서 free된 메모리에 기록되는 값은 `CreateHTMLElement()`의 리턴값으로 이는 제어할수없으며, `orphan`상태이므로, 그 내용은  reliable하지 않다.<br>
  
하지만, offset을 `mHandlesused`의 값에 따라 조절할수있다.<br>
  
 `mHandlesUsed`는 파싱과정의 모든 HTML element들에 대해 증가한다.<br>
  
```c
<br&gt;                          <-- mHandlesUsed = 0
<br&gt;                          <-- mHandlesUsed = 1
<br&gt;                          <-- mHandlesUsed = 2
<br&gt;                          <-- mHandlesUsed = 3
<br&gt;                          <-- mHandlesUsed = 4
<br&gt;                          <-- mHandlesUsed = 5
<br&gt;                          <-- mHandlesUsed = 6
<span is=custom-span&gt;</span&gt;  <-- mHandlesUsed = 7
```
위에서 `mHandles`의 주소가 `0x7f0ed4f0e000`이고, `span`요소가 버그를 트리거하면, 새로작성된 `HTMLSpanElement`의 객체의 주소가 `0x7f0ed4f0e000 + (7 * sizeof(nsIContent*)) == 0x7f0ed4f0e038`에 쓰이게 된다.<br>
  
  
##  Surviving document destruction
  
  
버그를 트리거하기 위해서는 현재 페이지를 벗어나야하고, 현재 로드되는 문서를 abort시켜야한다.<br>
  
```c
JavaScript error: , line 0: NotSupportedError: Refusing to execute function from window whose document is no longer active.
```
다음과 같이 constructor function이 리턴되면 JavaScript를 실행시킬수 없다.<br>
  
Exploit을 하기위해서는 버그가 트리거된후 여러 JavaScript logic을 실행시켜야한다.<br>
  
이를 위해 버그를 넣은 `child iframe element`를 `HTML과 JavaScript 코드`내부에 만들어주는 메인 웹 페이지를 사용할수있다.<br>
  
버그가 트리거된이후에 `child iframe`의 문서는 `about:blank`로 변경된후에도 유지되고, 해당 context에서 나머지 JavaScript 로직을 실행시킬수있다.<br>
  
  
![enter image description here](https://github.com/Kieast/image/blob/master/document.png?raw=true )
  
위 그림은 child iframe을 만드는 HTML페이지의 예시이다.<br>
  
##  General direction for exploitation
  
  
`Exploit`을 하기위해서는 free된 `mHandles`에 객체를 심어서 주어진 오프셋에서 메모리 주소 포인터를 덮어야한다.<br>
  
좋은 방법은 `ArrayObjects inside ArrayObjects` 기법이다.<br>
  
이는 `mHandles`에 `ArrayObjects`를 위치시키고 그것의 `length`헤더를 매우큰 값으로 덮어씌우는 방법이다.<br>
  
따라서, 악의적 형식의 `ArrayObject`개체에 대한 `length`가 변조되었으므로, 잘못된 객체가 만들어지고 더 많은 메모리를 읽기 혹은 쓰기를 할수있다.<br>
  
##  XMLHttpRequestMainThread as memory corruption target
  
  
XHR  객체는 몇가지 방식으로 응답은 받을수있는데, 그중하나는 `ArrayBuffer`를 사용하는 방법이다.<br>
  
```c
var oReq = new XMLHttpRequest();
oReq.open("GET", "/myfile.png", true);
oReq.responseType = [1]"arraybuffer";
  
oReq.onload = function (oEvent) {
  var arrayBuffer = [2]oReq.response;
  if (arrayBuffer) {
    var byteArray = new Uint8Array(arrayBuffer);
    for (var i = 0; i < byteArray.byteLength; i++) {
      // do something with each byte in the array
    }
  }
};
  
oReq.send(null);
```
위의 코드는 `[1]ArrayBuffer`를 통해 수신된 응답을 객체로 생성하는 엔진 함수이며, `XMLHttpRequest`의 `[2]reponse`에 접근시 일어난다.<br>
  
```c
JSObject* ArrayBufferBuilder::getArrayBuffer(JSContext* aCx) {
  if (mMapPtr) {
    JSObject* obj = JS::NewMappedArrayBufferWithContents(aCx, mLength, mMapPtr);
    if (!obj) {
      JS::ReleaseMappedArrayBufferContents(mMapPtr, mLength);
    }
    mMapPtr = nullptr;
  
    // The memory-mapped contents will be released when the ArrayBuffer
    // becomes detached or is GC'd.
    return obj;
}
```
위의 코드에서, `mMapPtr`을 함수 시작전에 변조하면, 기존의 return된 값이 아닌 `mMapPtr`에 넣은 주소의 값을 받게된다.<br>
  
따라서 return된 `ArrayBuffer`를 통해서 `read write`를 할수있게 된다.<br>
  
`XHR`객체를 변조가능한 상태로 prime하려면, `request`를 전송하고 `response`를 대기하는 상태이어야 한다.<br>
  
따라서, XHR에 의해 request되는 resource를 `Data URI`로 설정할수있다.<br>
  
```c
xhr.open("GET", "data:text/plain,xxxxxxxxxx", true);
```
  
`mMapPtr`는 `XMLHttpRequest`의 실제 구현 클래스인 `XMLHttpRequestMainThread`안의 `ArrayBufferBuilder`의 내부에 들어있으며, 사이즈는 `0x298`이다.<br>
  
  
![enter image description here](https://github.com/Kieast/image/blob/master/size.png?raw=true )
  
  
크기가 `0x298`는 `0x400`크기의 class bin에 들어가므로, `00xXXXXXXXXX000, 0xXXXXXXXXX400, 0xXXXXXXXXX800 또는 0xXXXXXXXXXc00 `중 하나에 속하는 메모리 주소에 개체가 항상 배치된다.<br>
  
이 사이즈는 `mHandles`의 `0xXXXXXXXXX000`인 할당 패턴과 잘 맞는다.<br>
  
`mArrayBufferBuilder.mMapPtr`의 값을 변조하려면, free된 `mHandles`에 `0x250byte`를 목표로 해야한다.<br>
  
![enter image description here](https://github.com/Kieast/image/blob/master/mhandles.png?raw=true )
  
따라서, `XMLHttpRequestMainThread`이 타겟인데, `mHandles`의 사이즈가 다르므로 `Run Cycling`테크닉을 사용해야한다.<br>
  
힙이 이러한 방식으로 작동하도록 `grooming`하는데 필요한 작업을 수행하기 위해 다른 개체 유형을 사용한다.<br>
  
##  FormData for Heap Grooming
  
  
`FormData`는 object타입으로 제공할 `key/value`쌍들을 보유한다.<br>
  
```c
var formData = new FormData();
formData.append("username", "Groucho");
formData.append("accountnum", "123456");
```
내부적으로는 `FormDataTuple`을 사용하여, `key/value`쌍을 보유하고, `mFormData`를 저장하기 위해 사용한다.<br>
  
`mFormData`는 기본적으로 빈 array이다.<br>
  
`append()`와 `delete()`를 요소 추가 및 삭제를 위해 사용한다.<br>
  
`nsTArray`클래스는  각 요소의 동적 메모리 할당을 위해 사용한다.<br>
  
```c
nsTArray_base<Alloc, Copy&gt;::EnsureCapacity(size_type aCapacity,
                                           size_type aElemSize) {
    ...
    size_t reqSize = sizeof(Header) + aCapacity * aElemSize;
    ...
    // Round up to the next power of two.
    bytesToAlloc = mozilla::RoundUpPow2(reqSize);
    ...
    header = static_cast<Header*&gt;(ActualAlloc::Realloc(mHdr, bytesToAlloc));
```
  
위는 `FormData`가 할당할 사이즈를 고르는 코드이다.<br>
  
```c
sizeof(Header) == sizeof(nsTArrayHeader) == 8
aElemSize == sizeof(FormDataTuple) == 0x30
```
위와 같이 사이즈를 가정하자.<br>
```c
bytesToAlloc = RoundUpPow2(8 + aCapacity * 0x30)
```
`bytesToAlloc`은 `aCapacity`의 요소 수의 함수로 버퍼 할당 크기를 얻는 공식을 통한 값이다.<br>
  
이 과정을 통해 `mFormData`가 11번째 페어에는 0x400(1024)bytes를 `realloc()`할것을 알수있다.<br>
  
22번째에는 `0x800`바이트를 할당한다.<br>
  
이 버퍼들의 주소는 `mFormData.mHdr`에 저장된다.<br>
  
`mFormData.mHdr`의 비할당을 일으키기위해서는 `delete()`메소드를 사용하면 된다.<br>
  
array에서 제거하기 위해서는 단일 키이름을 파라미터로 사용하지만, 다른 쌍들도 동일한 키이름을 사용한다.<br>
  
따라서, 같은 키가 모든 쌍에서 재사용 된다면, `delete()`를 호출함으로써 전체 배열을 한번에 clear시킬수 있다.<br>
  
`nsTArray_base`객체는 요소가 0이될때까지 진행하면, `mHdr`은 프리된다.<br>
  
요약하면 `FormData`객체를 Firefox heap에 맞는 적당한 크기로 임의 할당및 할당 해제를 할수있다.<br>
  
위의 내용을 통해, 0x1000 size 할당 대신 0x400크기의 클래스 할당을 할수있다.<br>
  
![enter image description here](https://github.com/Kieast/image/blob/master/spray.png?raw=true )
  
*  0x1000 spray
`FormData`객체를 여러개 생성하고, 각 개체에 43개의 쌍을 부여한다.<br>
따라서 힙은 `mFormData.mHdr` 버퍼를 포함한 0x1000사이즈의 청크가 꽉 찰것이다.<br>
<br>
* Poke holes
delete()를 `mFormData.mHdr` 버퍼를 비할당 하기위해 사용하고, 버퍼사이에 0x1000사이즈 만큼의 free된 공간이 생기게 된다.<br>
<br>
  
* Trigger mHandles's allocation
`child iframe`을 추가하면, HTML파서와 `mHandles`가 할당된 `nsHtml5TreeBuilder`의 생성을 유도한다.<br>
`LIFO free list`때문에 이전단계에서 free된 주소와 같은 주소에 `mHandles`를 할당시켜야 한다.<br>
<br>
* Free mHandles
 mHandles를 free 시킨다.<br>
<br>
* Free all 0x1000 allocations
`delete()`메소드를 이용하여 모든 `FormData`를 지운다.<br>
<br>
* Spray 0x400 allocations
`XMLHttpRequest`를 많이 생성한다.<br>
  
위의 과정을 올바르게 수행했다면
  